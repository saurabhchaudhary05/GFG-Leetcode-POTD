#Day 199 Problem-Solving with #GFG POTD and #Leetcode

Today, I solved two interesting problems, one involving grid traversal with cost optimization and the other focusing on linked list reversal. Here's a summary of the problems and my approaches:



Problem 1: Minimum Cost to Make at Least One Valid Path in a Grid

Problem Description:

Given a grid where each cell has a direction sign, determine the minimum cost to modify the grid so that a valid path exists from the top-left to the bottom-right corner.



Approach:

1) Priority-Based Pathfinding:

â€¢ Use a 0-1 BFS (Breadth-First Search with deque).

â€¢ Traverse the grid using the current cell's direction with zero cost.



2) Modify the Path:

â€¢ If moving in the given direction isn't feasible, push the modified cell to the back of the deque with a cost of 1.



3) Optimization with Deque:

â€¢ The deque ensures that zero-cost moves are processed before costlier moves.



Complexity:

â€¢ Time: O(mÃ—n), where m and n are the dimensions of the grid.

â€¢ Space: O(mÃ—n), for the visited array and deque.



Problem 2: Reverse a Linked List

Problem Description:

Given the head of a linked list, reverse the list and return the new head.



Approach:

1) Iterative Approach:

â€¢ Maintain three pointers: prev, current, and next.

â€¢ Traverse the list, reversing the direction of current.next to point to prev.



2) Recursive Approach:

â€¢ Use recursion to reverse the rest of the list and adjust the pointers accordingly.



Complexity:

â€¢ Time: O(n), where n is the number of nodes in the linked list.



Space:

â€¢ Iterative: O(1), in-place reversal.

â€¢ Recursive: O(n), due to the recursion stack.



Reflection:

1) Minimum Cost to Make at Least One Valid Path in a Grid:

â€¢ Leveraging 0-1 BFS effectively minimized costs and ensured optimal pathfinding.



2) Reverse a Linked List:

â€¢ This classic problem reinforces fundamental concepts of pointer manipulation and recursion.

#GridTraversal #LinkedList #BFS #GFG160 #GeekStreak2024 ðŸš€

