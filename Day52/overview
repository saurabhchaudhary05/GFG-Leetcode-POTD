#Day 171: Problem-Solving with #GFG POTD and #LeetCode

Today, I worked on two interesting problems involving chunk-based sorting and number manipulation. Here's an overview of the approaches and solutions:



Problem 1: Max Chunks to Make Sorted

Problem Description

Given an integer array arr of length nnn, representing a permutation of integers in the range [0,nâˆ’1][0, n - 1][0,nâˆ’1], split the array into the maximum number of chunks such that sorting each chunk and concatenating them results in a fully sorted array.



Example:

Input:

arr = [4, 3, 2, 1, 0]

Output:

1



Input:

arr = [1, 0, 2, 3, 4]

Output:

4



Approach:

1) Track the Maximum:

â€¢ Maintain a variable max_so_far to track the maximum value encountered 

2) while traversing the array.

â€¢ For each index iii, if max_so_far equals the index iii, it indicates that the chunk can be split here because all elements in the chunk are already sorted when compared to the global indices.



Steps:

â€¢ Initialize max_so_far = 0 and chunks = 0.

â€¢ Traverse the array:

â€¢ Update max_so_far as the maximum of max_so_far and the current element.

â€¢ If max_so_far == i, increment chunks as a chunk can be formed.

â€¢ Return chunks.



Complexity:

â€¢ Time: O(n), as we traverse the array once.

â€¢ Space: O(1), as no extra space is used.



Problem 2: Kth Missing Positive Number in a Sorted Array

Problem Description

Given a sorted array arr of distinct positive integers, find the kkk-th missing positive integer from the sequence of natural numbers.



Example:

Input:

arr = [2, 3, 4, 7, 11], k = 5

Output:

9



Input:

arr = [1, 2, 3, 4], k = 2

Output:

6



Approach:

1) Iterative Approach:

â€¢ Calculate the total number of missing integers before each element in the array.

â€¢ For each element arr[i], the count of missing numbers before it is given by arr[i] - (i + 1).

â€¢ Stop once the missing count is greater than or equal to kkk.



2) Binary Search Optimization:

â€¢ Use binary search to find the first position where the missing count before arr[i] is greater than or equal to k.

â€¢ If k is not reached within the array, calculate the missing number outside the array.



Steps:

â€¢ Initialize low=0,, high = n - 1

â€¢ Perform binary search:

â€¢ Compute missing = arr[mid] - (mid + 1).

â€¢ If missing < k, move low to mid + 1.

â€¢ Otherwise, move high to mid - 1.

â€¢ After binary search:

If k is greater than the last missing count, return arr[n - 1] + (k - missing).

â€¢ Otherwise, calculate the missing number using the final low.



Complexity:

â€¢ Time: O(logâ¡n), for binary search.

Space: O(1).



Reflection:

â€¢ Max Chunks to Make Sorted:

â€¢ Highlights the importance of tracking ranges and indices efficiently for sorting-based partitioning.

â€¢ Kth Missing Positive Number:

â€¢ A great example of leveraging binary search to optimize problems involving missing elements.

â€¢ Both problems reinforced the utility of efficient traversal and binary search for problem-solving.

#Arrays #BinarySearch #Sorting #GFGPOTD #LeetCodeDaily #geekstreak2024 ðŸš€
