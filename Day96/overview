#Day 216 Problem-Solving #GFG potd and #leetcode

Problem 1: Convert a Binary Tree to its Mirror Tree



Problem Description:

Given a binary tree, convert it to its mirror tree.

In a mirror tree, left and right children of all non-leaf nodes are swapped.



Approach:

1) Recursive DFS (Depth-First Search):

â€¢ Swap the left and right child at each node.

â€¢ Recursively mirror the left and right subtrees.

â€¢ Base Case: If the node is NULL, return.

â€¢ Iterative Approach (Using Queue - BFS):



2) Use a queue (BFS traversal).

â€¢ Swap left and right children at each level while processing nodes.



Complexity Analysis:

â€¢ Time Complexity: O(n) (each node is visited once).

â€¢ Space Complexity: O(h) (recursive depth, where hhh is tree height) in DFS, O(n)O(n)O(n) in BFS (queue storage).



Problem 2: Check if One String Swap Can Make Strings Equal

Problem Description:

Given two strings s1 and s2 of equal length, determine if they can be made equal by performing at most one swap in one of the strings.



Approach:

1) Compare Characters at Mismatched Positions:

â€¢ If s1 == s2, they are already equal â†’ return true.

â€¢ Find indices where s1[i] != s2[i].

â€¢ If there are more than 2 mismatches, return false.

â€¢ If exactly 2 mismatches, check if swapping the characters makes them equal.



2) Implementation Details:

â€¢ Use a list to store mismatch indices.

â€¢ If mismatch count is not 0 or 2, return false.

â€¢ If there are exactly 2 mismatches, check if swapping makes s1 == s2.



Complexity Analysis:

â€¢ Time Complexity: O(n) (one pass to find mismatches, one check for swap).

â€¢ Space Complexity: O(1) (only a few variables used).



Reflection:

1) Mirror Tree:

â€¢ Strengthened tree traversal techniques.

â€¢ Practiced both recursive and iterative approaches.



2) String Swap Check:

â€¢ Improved string comparison skills.

â€¢ Learned to efficiently find mismatched positions and validate swap conditions.

#BinaryTree #Recursion #BFS #StringManipulation #Greedy ðŸš€

