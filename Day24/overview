Todayâ€™s journey involved tackling two interesting problems that required a blend of grid traversal and dynamic programming. Here's what I learned:

ðŸ”¹ Problem 1: Count Unguarded Cells in the Grid
Problem Statement:
Given a mÃ—nm \times nmÃ—n grid, some cells are occupied by guards, and others by walls. A guard can monitor cells in all cardinal directions (north, east, south, west) until obstructed by a wall or another guard. The task is to determine the number of unoccupied cells that are not under surveillance by any guard.

Approach:
1) Mark Guarded Cells:
â€¢ Use the positions of guards to simulate their vision.
â€¢ Traverse in each direction (up, down, left, right) from every guard's position, marking cells as guarded until a wall or another guard is encountered.

2) Avoid Redundant Traversal:
â€¢ Use auxiliary matrices or flags to mark cells as guarded during the traversal to avoid revisiting.

3) Count Unguarded Cells:
â€¢ After processing guards and walls, count the unoccupied cells that remain unguarded.

Challenges Faced:
1) Efficiently simulating the vision of guards without redundant computations.
2) Handling edge cases where the grid was heavily populated with walls or guards.

â€¢ Key Takeaway: Simulation problems on grids are greatly optimized using directional traversal techniques, coupled with clear boundary conditions.

ðŸ”¹ Problem 2: Stock Buy and Sell â€“ Multiple Transactions Allowed
Problem Statement:
Given the prices of a stock over nnn days, find the maximum profit obtainable by performing as many transactions as desired (buying and selling the stock). You can only sell after buying, and you cannot hold multiple stocks at the same time.

Approach:
1) Greedy Strategy:
â€¢ Whenever a price dip is followed by a rise, calculate the profit for that transaction (buy at the dip, sell at the peak).
â€¢ Iterate through the price array and accumulate the profit for each profitable transaction.

2) Dynamic Programming (For Further Optimization):
â€¢ Maintain two states: hold (maximum profit holding a stock) and no_hold (maximum profit without holding a stock).
â€¢ Update these states iteratively based on whether you buy, sell, or skip on a given day.

Challenges Faced:
â€¢ Understanding and optimizing the transition between holding and not holding states.
â€¢ Avoiding over-complication of the problem with unnecessary conditions.

â€¢ Key Takeaway: The greedy approach simplifies the problem when transactions are unrestricted, but understanding DP transitions helps in scenarios with added constraints.

ðŸŽ¯ What I Learned Today:
â€¢ Grid-based problems often require robust simulation techniques and efficient traversal mechanisms.
â€¢ Greedy methods are invaluable for profit maximization problems when constraints are minimal.
â€¢Transition states DP problems need clear definitions to avoid missteps in implementation.
hashtag#GridTraversal | hashtag#DynamicProgramming | hashtag#ProblemSolving | hashtag#CodingJourney | hashtag#DSA hashtag#gfg160 hashtag#geekstreak2024
