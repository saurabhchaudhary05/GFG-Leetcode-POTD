Day 222 of solving #GFG potd and #leetcode

Problem 1: Remove All Occurrences of a Substring ‚úÇÔ∏èüî°

Problem Description:

Given two strings s and part, repeatedly remove the leftmost occurrence of part from s until part no longer exists in s.

 Return the modified string.



Approach:

1Ô∏è‚É£ Iterative String Replacement:

 ‚Ä¢ Use the find() function to locate the first occurrence of part in s.

 ‚Ä¢ Remove it and continue searching until part is no longer found.

2Ô∏è‚É£ Using Stack for Efficient Processing:

 ‚Ä¢ Iterate through s, pushing characters onto a stack.

 ‚Ä¢ After each insertion, check if the last characters in the stack match part.

 ‚Ä¢ If found, remove them from the stack.



Complexity:

‚Ä¢ Time Complexity: O(NM) (for repeated substring search & removal)

 ‚Ä¢ Space Complexity: O(N) (for stack-based approach)



Problem 2: Check for BST üå≥‚úÖ

Problem Description:

Given the root of a binary tree, check whether it is a Binary Search Tree (BST).

 A BST must satisfy:

Left subtree < Root

Right subtree > Root

Both subtrees must be valid BSTs



Approach:

1Ô∏è‚É£ Recursive Inorder Traversal:

 ‚Ä¢ Perform an inorder traversal (Left ‚Üí Root ‚Üí Right).

 ‚Ä¢ If the traversal is sorted, the tree is a BST.

2Ô∏è‚É£ Using Min-Max Approach:

 ‚Ä¢ Each node must be within a valid range (min,max)(min, max).

 ‚Ä¢ Recursively check:

Left subtree: Valid if all values < root.

Right subtree: Valid if all values > root.



Complexity:

‚Ä¢ Time Complexity: O(N)

 ‚Ä¢ Space Complexity:  (H = height of the tree for recursion stack)



Reflection:

‚úÖ String Manipulation: Mastered iterative and stack-based substring removal techniques.

 ‚úÖ BST Validation: Strengthened understanding of inorder traversal and min-max constraints.

 ‚úÖ Enhanced Problem-Solving: Improved efficiency in tree-based and string processing problems.

 #BinarySearchTree #BST #InorderTraversal #StringProcessing #Stack #CodingChallenge
