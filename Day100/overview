Day 220 of solving #GFG potd and #leetcode

Problem 1: Maximum Path Sum from Any Node üå≥

Problem Description:

Given a binary tree, find the maximum path sum, where the path can start and end at any node.



Approach:

1Ô∏è‚É£ Recursive DFS Traversal:

 ‚Ä¢ Compute the max path sum passing through each node.

 ‚Ä¢ Maintain a global max to store the highest sum encountered.

2Ô∏è‚É£ Steps:

 ‚Ä¢ Recursively calculate the max sum from left and right subtrees.

 ‚Ä¢ The max path sum at a node = node value + max(left, right, 0).

 ‚Ä¢ Update the global max considering paths that pass through the node.



Complexity:

‚Ä¢ Time Complexity: O(N)

 ‚Ä¢ Space Complexity: O(H) (H = tree height)



Problem 2: Count Number of Bad Pairs üî¢

Problem Description:

Given a 0-indexed array nums, a pair (i, j) is bad if:

j‚àíi‚â†nums[j]‚àínums[i]Find the total number of bad pairs in the array.



Approach:

1Ô∏è‚É£ Transform the Condition:

 Rewriting the equation:

nums[j]‚àíj‚â†nums[i]‚àíiDefine a new transformed array:

value=nums[i]‚àíiA pair is good if it has the same value, so a pair is bad otherwise.

2Ô∏è‚É£ Steps:

 ‚Ä¢ Use a HashMap to store frequency of nums[i] - i.

 ‚Ä¢ Total pairs = n * (n - 1) / 2

 ‚Ä¢ Subtract the good pairs from total to get the bad pairs.



Complexity:

‚Ä¢ Time Complexity: O(N)

 ‚Ä¢ Space Complexity: O(N)



Reflection:

‚úÖ Binary Tree Mastery: Strengthened DFS traversal for max path sum problems.

 ‚úÖ Optimized Counting with HashMap: Learned efficient pair counting with prefix sum properties.

 ‚úÖ Improved Problem-Solving Speed: Practiced breaking complex conditions into simpler transformations.

 #BinaryTree #DFS #HashMap #PrefixSum #CodingJourney #ProblemSolving
