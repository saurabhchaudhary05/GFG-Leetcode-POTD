Today, I delved into subarray manipulations and permutations. Here's what I solved:



ðŸ” Maximum Sum of Distinct Subarrays With Length K

Problem Statement: Find the maximum sum of subarrays of size kkk where all elements are distinct.



Approach:

â€¢ Sliding Window with HashSet:

1) Used a sliding window technique to traverse the array, keeping track of distinct elements with a HashSet.

2) Maintained a running sum for the window and updated the maximum sum when conditions were met.

â€¢ Adjusted the window dynamically when duplicate elements were encountered.

â€¢ Edge Cases: Handled scenarios where no valid subarray exists (e.g., k>nk > nk>n).



Key Takeaways:

â€¢ Hashing and sliding window methods effectively solve subarray problems with constraints.

â€¢ Reinforced understanding of balancing time and space efficiency.



ðŸ”— Next Permutation

Problem Statement: Rearrange an array into its lexicographically next greater permutation.



Approach:

1) Reverse-Engineering Lexicographical Order:

â€¢ Identified the first pair of indices iii and i+1i+1i+1 (from right to left) where arr[i]<arr[i+1]arr[i] < arr[i+1]arr[i]<arr[i+1].

â€¢ Swapped arr[i]arr[i]arr[i] with the smallest element on the right that's greater than arr[i]arr[i]arr[i].

2) Reversed the subarray to the right of iii to achieve the next permutation.

3) Edge Cases: If no valid permutation exists (array is in descending order), returned the smallest permutation by sorting.



Key Takeaways:

â€¢ Learned to implement permutation algorithms systematically.

â€¢ Gained insight into leveraging array properties for in-place modifications.



ðŸ“š Reflections:

â€¢ Subarray problems highlight the importance of efficient iteration and condition-checking.

â€¢ Permutations demand attention to detail for proper index manipulations.
