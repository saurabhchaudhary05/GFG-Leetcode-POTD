#Day 175 Problems solving with #GFGPOTD and #leetcode



Problem 1: Minimum Number of Operations to Sort a Binary Tree by Level

Problem Description

Given the root of a binary tree with unique values, determine the minimum number of swaps required to make the values at each level sorted in strictly increasing order.

You can swap values of any two nodes at the same level.

The goal is to perform the minimum number of operations.



Example:

Input:

      1  

     / \  

    3   2  

   / \ / \  

  7  6 5  4  

Output:

3



Approach:

1) Level Order Traversal:

‚Ä¢ Perform a level-order traversal to extract node values level by level.

‚Ä¢ For each level, record the values in an array.



2) Sort with Minimum Swaps:

‚Ä¢ For each level, count the minimum swaps needed to sort the array using a cycle detection method in a graph:

‚Ä¢ Create an array of pairs (value,index)(value, index)(value,index) and sort it by value.

‚Ä¢ Use visited nodes to detect cycles and count the number of swaps for each cycle.



3) Sum Up Operations:

‚Ä¢ Add the number of swaps across all levels.



Complexity:

‚Ä¢ Time: O(n‚ãÖlog‚Å°n) where n is the total number of nodes.

‚Ä¢ Space: O(n)O(n)O(n) for storing levels and visited nodes.



Problem 2: Search in a Row-Wise Sorted Matrix

Problem Description

Given a row-wise sorted matrix mat[][]mat[][]mat[][] of size n√ómn \times, determine if an integer x exists in the matrix.

Example:

Input:

mat = [[1, 3, 5, 7],  

       [10, 11, 16, 20],  

       [23, 30, 34, 50]]  

x = 3  



Output:

True



Approach:

1) Binary Search in Rows:

‚Ä¢ Iterate through each row and apply binary search to find xxx.



2) Optimized Search (Skip Rows):

‚Ä¢ Use the sorted property:

‚Ä¢ Start at the beginning of the row and check if xxx lies within the range of the current row's minimum and maximum.



3) Apply binary search on the identified row.

‚Ä¢ Alternative Search from Top-Right Corner:

‚Ä¢ Start at the top-right element:



Complexity:

‚Ä¢ Binary Search Approach: O(n‚ãÖlog‚Å°m), where n is the number of rows and m is the number of columns.

‚Ä¢ Optimized Search: O(n+m), since each row or column is traversed at most once.



Reflection:

1) Binary Tree Level Sorting:

‚Ä¢ It was interesting to apply cycle detection for determining minimum swaps, which is typically used in permutation problems.

2) Matrix Search:

‚Ä¢ Reinforced understanding of matrix traversal techniques and the importance of exploiting structure (sorted rows).

‚Ä¢ Both problems offered a mix of graph-based techniques and matrix manipulation.

#TreeSorting #MatrixSearch #GraphCycles #EfficientAlgorithms üöÄ

#gfg160 #geekstreak2024

